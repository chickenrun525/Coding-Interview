Design a twitter

functions: tweeting, timeline (user timeline, home timeline), following,
database:
user table: id, name,
tweets: id, content, user

Most of twitter is read intensive (300k QPS), not much write intensive (5k QPS), time critically, but availability comes first.

message ----> put ----> load balancer ----> Redis (3 places)

precomputing before somebody refreshes his home timeline, kept in memory based database (Redis), probably for active users based on history.
So the first time somebody logged into twitter, might take a little while. It is a way more read intensive than write intensive especially considering tweets could have videos and photos.

Sharding based on user_id would result in hot users, like JB and Lady Gaga, so sharding based on twitter id is an option. But this one brings another trouble that
fetching somebody's tweest would need to query a tons of servers, high latency. So need cache before. Or use user_id as sharing but consistent hashing.

Instagram id, tweets id, message id would be all generated by epoch time + aotu increment counter.

When talking about cache, mention the type of cache we use. Then talk about strategy, here, LRU is one, 80-20 rule is another one and  cache all latest 3 days tweets is another one as tweet popularity depends on time a lot.

Load balancer: needs to think where to add. In this case, between clients to app servers, between app servers to database replication server and between aggregation server to cache server.
LB strategy: Round Robin is simple but needs to consider huge workload for some job so LB needs to check the workload.

For somebody's home timeline table: tweet id, sender.
Disadvantages: some super celebrities, huge number of followers, you might see your friends' action on his tweets before you see his original one, because update 100M*3 redis takes much more than your friend(100 followers)'s action.
For them, JB's tweets will be loaded into SQL then mix with Redis calculation.

Space not a very problem, because of 140 chars limit, not limiting to videos and images(not many).

User ----> Browser (GET) ----> LB -----> 3 Redis, the fastest one responds back to user timeline
Use HashMap look up where user A Redis are stored.

Some other functions: search pipeline (every tweets has its own index, easy for everyone to search), push notification, advertisement.

SQL: RDBMS, NoSQL: tweets, media/graph
For images/video storage, use file systems. Rest either SQL or NoSQL.

Fist model: pull model, user sends request to web server, getting the following lists, check their tweets recently, merge to top K ones, return and display
Fan-out structure: push model, same as above, Redis model, this process is asynchronous, not so much time critical. This is the "new feed table"
Still needs tweets table to store all of the tweets from everyone, new feed table and user table, and relationship table
Why pull model has better time critically while push model does not have?
De Chao's problem in slides? Is it solved?
Some other potential questions? How to follow and unfollow? How to quickly find common friends? How to save likes and what will happen if many likes somebody's post?

Pull model is for user timeline, push model + pull model (for popular stars) is for home timeline (new feed).
No need to update new feed table (cached) every 5 minutes, only when user changes its login state or he/she asks for a refresh, the system update the cache.
